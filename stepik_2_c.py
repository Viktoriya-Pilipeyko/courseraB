# Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
# y больше или равно x
# y делится нацело на 5

""" def closest_mod_5(x):
    y = x
    if x % 5 == 0:
        return y
    else:
        return y + (5 - (y % 5))

print(closest_mod_5(16)) """

# Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
# Два сочетания называются различными, если одно из сочетаний содержит элемент, который не содержит другое.
# Числом сочетаний из n по k называется количество различных сочетаний из n по k. Обозначим это число за C(n, k).
# Пример:
# Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
# Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
# Различных сочетаний три, поэтому C(3, 2) = 3.
# Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом, а именно, ничего не выбрать.
# Также несложно понять, что если k > n, то C(n, k) = 0, так как невозможно, например, из трех элементов выбрать пять.
# Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
# C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
# Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
# Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
# Ваша программа должна вывести единственное число: C(n, k).
# Примечание:
# Считать два числа n и k вы можете, например, следующим образом:
# n, k = map(int, input().split())

""" def C(n,k):
    if k == 0:
        return 1
    elif k > n:
        return 0
    else:
        return C(n - 1, k) + C(n - 1, k - 1)

n, k = map(int, input().split())

print(C(n, k)) """

# Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.
# В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.
# Вашей программе на вход подаются следующие запросы:
# create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent>
# add <namespace> <var> – добавить в пространство <namespace> переменную <var>
# get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var> при запросе из пространства <namespace>, или None, если такого пространства не существует
# Рассмотрим набор запросов
# add global a
# create foo global
# add foo b
# create bar foo
# add bar a
# Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен, созданной при выполнении данного кода
# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2
# В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global. 
# Далее мы объявляем функцию foo, что влечет за собой создание локального для нее пространства имен внутри пространства global. 
# В нашем случае, это описывается командой create foo global. Далее мы объявляем внутри функции foo функцию bar, тем самым создавая пространство bar внутри пространства foo, 
# и добавляем в bar переменную a.
# Добавим запросы get к нашим запросам
# get foo a
# get foo c
# get bar a
# get bar b
# Представим как это могло бы выглядеть в коде
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)
# Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
# Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a, но в пространстве global, внутри которого находится 
# пространство foo, она объявлена. Аналогично, результатом запроса get bar b будет являться foo, а результатом работы get bar a будет являться bar.
# Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем пространстве global не была объявлена переменная с.
# Более формально, результатом работы get <namespace> <var> является
# <namespace>, если в пространстве <namespace> была объявлена переменная <var>
# get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>, если переменная не была объявлена
# None, если не существует <parent>, т. е. <namespace>﻿ – это global
# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
# В каждой из следующих n строк дано по одному запросу.
# Запросы выполняются в порядке, в котором они даны во входных данных.
# Имена пространства имен и имена переменных представляют из себя строки длины не более 10, состоящие из строчных латинских букв.
# Формат выходных данных
# Для каждого запроса get выведите в отдельной строке его результат.

""" list_of_structure = [input().split() for i in range(int(input()))]

scopes = {'global': {'func': [], 'vars': []}}

def add(scopes, where, what):
    if where in scopes:
        scopes[where]['vars'].append(what)
    else:
        print('добавление невозможно, так как такой области')

def create(what, where):
    global scopes
    if where in scopes:
        scopes[what] = {'func': [], 'vars': [], 'parent': where}
        scopes[where]['func'].append(what)
    else:
        print('создание невозможно, так как такой области')



def get(where, what):
    global scopes
    if what in scopes[where]['vars']:
        print(where)
    else:
        try:
            upper_namespace = scopes[where]['parent']
            return get(upper_namespace, what)
        except KeyError:
            print('None')


for i in range(len(list_of_structure)):
    if list_of_structure[i][0] == 'add':
        add(scopes, list_of_structure[i][1],list_of_structure[i][2])
    elif list_of_structure[i][0] == 'create':
        create(list_of_structure[i][1],list_of_structure[i][2])
    elif list_of_structure[i][0] == 'get':
        get(list_of_structure[i][1],list_of_structure[i][2])

#print(scopes) """

# Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
# Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в копилку. 
# Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в копилку и узнавать, 
# можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.
# Класс должен иметь следующий вид
# При создании копилки, число монет в ней равно 0.
# Примечание:
# Гарантируется, что метод add(self, v) будет вызываться только если can_add(self, v) – True.

""" class MoneyBox:
    def __init__(self, capacity = 0):
        # конструктор с аргументом – вместимость копилки
        self.capacity = capacity
        self.count = 0
    def can_add(self, v):
        # True, если можно добавить v монет, False иначе
        return self.count + v <= self.capacity

    def add(self, v):
        # положить v монет в копилку
        if self.can_add(v) == True:
            self.count += v """

# Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой последовательности, 
# затем сумму второй пятерки, и т. д.
# Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. 
# Например, сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
# Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок последовательных элементов по мере их накопления.
# Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, 
# т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
# Обратите внимание, что во время выполнения метода add выводить сумму пятерок может потребоваться несколько раз до тех пор, пока в буфере не останется менее пяти элементов.

""" class Buffer:
    def __init__(self):
        # конструктор без аргументов
        self.lst = []
    def add(self, *a):
        # добавить следующую часть последовательности
        self.lst.extend([*a])
        q = 0
        w = 5
        for j in range(len(self.lst) // 5):
            sum = 0
            for i in range(q,w):
                sum += int(self.lst[i])
            q = w
            w += 5
            print(sum)
        lenm = len(self.lst) // 5
        self.lst[0:5 * lenm] = []
    def get_current_part(self):
        # вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были добавлены
        return self.lst """

# Вам необходимо отвечать на запросы, является ли один класс предком другого класса

""" classes = {}

def add_class(classes, class_name, parents):
    if class_name not in classes:
        classes[class_name] = []
    classes[class_name].extend(parents)
    for parent in parents:
        if parent not in classes:
            classes[parent] = []

def found_path(classes, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if start not in classes:
        return None
    for node in classes[start]:
        if node not in path:
            newpath = found_path(classes, node, end, path)
            if newpath: return newpath4
    return None

def answer(classes, parent, child):
    if not(parent or child) in classes or not found_path(classes, child, parent):
        return 'No'
    return 'Yes'

n = int(input())
for _ in range(n):
    class_description = input().split()
    class_name = class_description[0]
    class_parents = class_description[2:]
    add_class(classes, class_name, class_parents)

q = int(input())
for _ in range(q):
    question = input().split()
    parent = question[0]
    child = question[1]
    print(answer(classes, parent, child)) """

# Реализуйте структуру данных, представляющую собой расширенную структуру стек. Необходимо поддерживать добавление элемента на вершину стека, 
# удаление с вершины стека, и необходимо поддерживать операции сложения, вычитания, умножения и целочисленного деления.
# Операция сложения на стеке определяется следующим образом. Со стека снимается верхний элемент (top1), затем снимается следующий верхний элемент (top2), 
# и затем как результат операции сложения на вершину стека кладется элемент, равный top1 + top2.
# Аналогичным образом определяются операции вычитания (top1 - top2), умножения (top1 * top2) и целочисленного деления (top1 // top2).
# Реализуйте эту структуру данных как класс ExtendedStack, отнаследовав его от стандартного класса list
# Требуемая структура класса:

""" class ExtendedStack(list):
    def sum(self):
        # операция сложения
        self.append(self.pop(-1) + self.pop(-1))
    def sub(self):
        # операция вычитания
        self.append(self.pop(-1) - self.pop(-1))

    def mul(self):
        # операция умножения
        self.append(self.pop(-1) * self.pop(-1))

    def div(self):
        # операция целочисленного деления
        self.append(self.pop(-1) // self.pop(-1)) """

# Одно из применений множественного наследование – расширение функциональности класса каким-то заранее определенным способом. 
# Например, если нам понадобится логировать какую-то информацию при обращении к методам класса.
# Рассмотрим класс Loggable:
# У него есть ровно один метод log, который позволяет выводить в лог (в данном случае в stdout) какое-то сообщение, добавляя при этом текущее время.
# Реализуйте класс LoggableList, отнаследовав его от классов list и Loggable таким образом, чтобы при добавлении элемента в 
# список посредством метода append в лог отправлялось сообщение, состоящее из только что добавленного элемента.
# Примечание
# Ваша программа не должна содержать класс Loggable. При проверке вашей программе будет доступен этот класс, и он будет содержать метод log, описанный выше.

""" class LoggableList(list, Loggable):
    def append(self,elem):
        super().append(elem)
        self.log(elem) """

# Вашей программе будет доступна функция foo, которая может бросать исключения.
# Вам необходимо написать код, который запускает эту функцию, затем ловит исключения ArithmeticError, AssertionError, ZeroDivisionError и выводит имя пойманного исключения.
# Пример решения, которое вы должны отправить на проверку.

""" try:
    foo()
except ZeroDivisionError:
    print("ZeroDivisionError")
except ArithmeticError:
    print("ArithmeticError")
except AssertionError:
    print("AssertionError") """

# Вам дано описание наследования классов исключений в следующем формате.
# <имя исключения 1> : <имя исключения 2> <имя исключения 3> ... <имя исключения k>
# Это означает, что исключение 1 наследуется от исключения 2, исключения 3, и т. д.
# Костя посмотрел на этот код и указал Антону на то, что некоторые исключения можно не ловить, так как ранее в коде будет пойман их предок. 
# Но Антон не помнит какие исключения наследуются от каких. Помогите ему выйти из неловкого положения и напишите программу, которая будет 
# определять обработку каких исключений можно удалить из кода.
# Важное примечание:
# В отличие от предыдущей задачи, типы исключений не созданы.
# Создавать классы исключений также не требуется
# Мы просим вас промоделировать этот процесс, и понять какие из исключений можно и не ловить, потому что мы уже ранее где-то поймали их предка.

""" exceptions = {}
throwed_exceptions = []

def found_path(exceptions, start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if start not in exceptions:
        return []
    for node in exceptions[start]:
        if node not in path:
            newpath = found_path(exceptions, node, end, path)
            if newpath: return newpath
    return []

n = int(input())
for _ in range(n):
    inpt = input().split()
    child = inpt[0]
    parents = inpt[2:]
    exceptions[child] = parents

m = int(input())
for _ in range(m):
    throwing = input()
    for throwed_exception in throwed_exceptions:
        if len(found_path(exceptions, throwing, throwed_exception)) > 1:
            print(throwing)
            break
    throwed_exceptions.append(throwing) """

    