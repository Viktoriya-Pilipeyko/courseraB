# Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
# y больше или равно x
# y делится нацело на 5

""" def closest_mod_5(x):
    y = x
    if x % 5 == 0:
        return y
    else:
        return y + (5 - (y % 5))

print(closest_mod_5(16)) """

# Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
# Два сочетания называются различными, если одно из сочетаний содержит элемент, который не содержит другое.
# Числом сочетаний из n по k называется количество различных сочетаний из n по k. Обозначим это число за C(n, k).
# Пример:
# Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
# Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
# Различных сочетаний три, поэтому C(3, 2) = 3.
# Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом, а именно, ничего не выбрать.
# Также несложно понять, что если k > n, то C(n, k) = 0, так как невозможно, например, из трех элементов выбрать пять.
# Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
# C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
# Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
# Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
# Ваша программа должна вывести единственное число: C(n, k).
# Примечание:
# Считать два числа n и k вы можете, например, следующим образом:
# n, k = map(int, input().split())

""" def C(n,k):
    if k == 0:
        return 1
    elif k > n:
        return 0
    else:
        return C(n - 1, k) + C(n - 1, k - 1)

n, k = map(int, input().split())

print(C(n, k)) """

# Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.
# В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.
# Вашей программе на вход подаются следующие запросы:
# create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent>
# add <namespace> <var> – добавить в пространство <namespace> переменную <var>
# get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var> при запросе из пространства <namespace>, или None, если такого пространства не существует
# Рассмотрим набор запросов
# add global a
# create foo global
# add foo b
# create bar foo
# add bar a
# Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен, созданной при выполнении данного кода
# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2
# В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global. 
# Далее мы объявляем функцию foo, что влечет за собой создание локального для нее пространства имен внутри пространства global. 
# В нашем случае, это описывается командой create foo global. Далее мы объявляем внутри функции foo функцию bar, тем самым создавая пространство bar внутри пространства foo, 
# и добавляем в bar переменную a.
# Добавим запросы get к нашим запросам
# get foo a
# get foo c
# get bar a
# get bar b
# Представим как это могло бы выглядеть в коде
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)
# Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
# Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a, но в пространстве global, внутри которого находится 
# пространство foo, она объявлена. Аналогично, результатом запроса get bar b будет являться foo, а результатом работы get bar a будет являться bar.
# Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем пространстве global не была объявлена переменная с.
# Более формально, результатом работы get <namespace> <var> является
# <namespace>, если в пространстве <namespace> была объявлена переменная <var>
# get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>, если переменная не была объявлена
# None, если не существует <parent>, т. е. <namespace>﻿ – это global
# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
# В каждой из следующих n строк дано по одному запросу.
# Запросы выполняются в порядке, в котором они даны во входных данных.
# Имена пространства имен и имена переменных представляют из себя строки длины не более 10, состоящие из строчных латинских букв.
# Формат выходных данных
# Для каждого запроса get выведите в отдельной строке его результат.

""" list_of_structure = [input().split() for i in range(int(input()))]

scopes = {'global': {'func': [], 'vars': []}}

def add(scopes, where, what):
    if where in scopes:
        scopes[where]['vars'].append(what)
    else:
        print('добавление невозможно, так как такой области')

def create(what, where):
    global scopes
    if where in scopes:
        scopes[what] = {'func': [], 'vars': [], 'parent': where}
        scopes[where]['func'].append(what)
    else:
        print('создание невозможно, так как такой области')



def get(where, what):
    global scopes
    if what in scopes[where]['vars']:
        print(where)
    else:
        try:
            upper_namespace = scopes[where]['parent']
            return get(upper_namespace, what)
        except KeyError:
            print('None')


for i in range(len(list_of_structure)):
    if list_of_structure[i][0] == 'add':
        add(scopes, list_of_structure[i][1],list_of_structure[i][2])
    elif list_of_structure[i][0] == 'create':
        create(list_of_structure[i][1],list_of_structure[i][2])
    elif list_of_structure[i][0] == 'get':
        get(list_of_structure[i][1],list_of_structure[i][2])

#print(scopes) """