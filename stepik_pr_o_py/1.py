""" a = int(input())
b = int(input())
c = int(input())
d = int(input())

for l in range(c, d+1):
    print('\t',l, end = '')
print('')
for i in range(a,(b+1)):
    print(i, end='')
    for j in range(c, d+1):
        print('\t', i * j, end = '')
    print('') """

""" a, b = (int(i) for i in input().split())
s = 0
c = 0

for i in range(a, b+1):
    if i % 3 == 0:
        s += i
        c += 1
print(s / c) """

""" a = input()
l = 'letter'
r = ''
for i in a:
    if i != l:
        r += i + str(a.count(i))
    l = i
print(r) """

""" s = str(input())
l = len(s)-1
c = 1
t = ''
if len(s)==1:
    t += s + str(c)
else:
    for i in range(l):
        if s[i] == s[i+1]:
            c += 1
        elif s[i]!=s[i+1]:
            t += s[i]+str(c)
            c = 1
    for j in range(l,l+1):
        if s[-1]==s[-2]:
            t = t +s[j]+str(c)
        elif s[-1]!=s[-2]:
            t += s[j]+str(c)
            c = 1
print(t) """

""" import webbrowser

webbrowser.open('https://jira.sberbank.ru/browse/LINEUP-26088', new = 2) """

""" l = [int(i) for i in input().split()]

for i in range(len(l)):
    if len(l) == 1:
        print(l[i])
    elif i == len(l) - 1:
        print(l[i-1] + l[0], end = ' ')
    else:
        print(l[i-1] + l[i+1], end = ' ') """

""" a = input().split()
a.sort()
l = []
for i in a:
    if a.count(i) == 1:
        continue
    elif a.count(i) > 1 and i not in l:
        print(i, end = ' ')
        l.append(i) """

#выводить сумму квадратов чисел, если сумма чисел равна 0
""" a = int(input())
s = a * a
while a != 0:
    i = int(input())
    s += i * i
    a += i

print(s) """

#Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется столько раз, чему равно). 
# На вход программе передаётся неотрицательное целое число n — столько элементов последовательности должна отобразить программа. 
# На выходе ожидается последовательность чисел, записанных через пробел в одну строку.
#Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.
""" a = int(input())
l = []

for i in range(1,a + 1):
    for j in range(1,i+1):
        if len(l) < a:
            l.append(i)
            print(i, end = ' ') """

#Напишите программу, которая считывает список чисел lstlst из первой строки и число xx из второй строки, 
# которая выводит все позиции, на которых встречается число xx в переданном списке lstlst.
#Позиции нумеруются с нуля, если число xx не встречается в списке, вывести строку "Отсутствует" (без кавычек, с большой буквы).
#Позиции должны быть выведены в одну строку, по возрастанию абсолютного значения.
""" lst = input().split()
x = int(input())
r = 0
for i, e in enumerate(lst):
    if int(e) == x:
        print(i, end = ' ')
        r = i
if r == 0:
    print('Отсутствует') """

#v2
""" lst = [int(i) for i in input().split()]
x = int(input())

for i in range(len(lst)):
	if x == lst[i]:
		print(i, end=' ')

if x not in lst:
    print('Отсутствует') """


#Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк. 
# После последней строки матрицы идёт строка, содержащая только строку "end" (без кавычек, см. Sample Input).
#Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен 
#сумме элементов первой матрицы на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с противоположной стороны матрицы.
#В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.
""" l = input()
lst = []
while l != 'end':
    lst.append([int(j) for j in l.split()])
    l = input()

for i in range(len(lst)):
    for j in range(len(lst[i])):
        if j == len(lst[i]) - 1 and i == len(lst)-1:
            print(lst[i-1][j] + lst[0][j] + lst[i][j-1] + lst[i][0], end = ' ')
        elif j == len(lst[i]) - 1:
            print(lst[i-1][j] + lst[i+1][j] + lst[i][j-1] + lst[i][0], end = ' ')
        elif i == len(lst)-1:
            print(lst[i-1][j] + lst[0][j] + lst[i][j-1] + lst[i][j+1], end = ' ')
        else:
            print(lst[i-1][j] + lst[i+1][j] + lst[i][j-1] + lst[i][j+1], end = ' ')
    print() """


#Выведите таблицу размером n \times nn×n, заполненную числами от 11 до n^2n 2
#по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере (здесь n=5n=5):

""" def spiral(n):
    dx,dy = 1,0           
    x,y = 0,0              
    myarray = [[None]* n for j in range(n)]
    for i in range(1,n**2+1):
        myarray[x][y] = i
        nx,ny = x+dx, y+dy
        if 0<=nx<n and 0<=ny<n and myarray[nx][ny] == None:
            x,y = nx,ny
        else:
            dx,dy = -dy,dx
            x,y = x+dx, y+dy
    return myarray
 
def printspiral(myarray):
    n = range(len(myarray))
    for y in n:
        for x in n:
            print (myarray[x][y],end=' ')
        print()

n = int(input())
printspiral(spiral(n)) """

# Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой:

""" def f(x):
    if x <= -2:
        return(1 - (x + 2)**2)
    elif -2 < x <= 2:
        return(-x / 2)
    elif 2 < x:
        return((x - 2)**2 +1)
print(f(4.5)) """

# Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а чётные нацело делит на два. 
# Функция не должна ничего возвращать, требуется только изменение переданного списка, например:

""" def modify_list(l):
    i, n = 0, len(l)
    while i < n:
        print(n)
        if l[i] % 2:
            print(i,n)
            l.pop(i)
            n -= 1
            print(i,n)
        else:
            print(i,n)
            l[i] = l[i] // 2
            i += 1
            print(i,n) """

# Напишите функцию update_dictionary(d, key, value), которая принимает на вход словарь dd и два числа: keykey и valuevalue.
# Если ключ keykey есть в словаре dd, то добавьте значение valuevalue в список, который хранится по этому ключу.
# Если ключа keykey нет в словаре, то нужно добавить значение в список по ключу 2 * key2∗key. 
# Если и ключа 2 * key2∗key нет, то нужно добавить ключ 2 * key2∗key в словарь и сопоставить ему список из переданного элемента [value][value].
# Требуется реализовать только эту функцию, кода вне её не должно быть.
# Функция не должна вызывать внутри себя функции input и print.

""" d = {}
def update_dictionary(d, key, value):
    if d.get(key):
        d[key].append(value)
    elif d.get(key * 2):
        d[(int(key) * 2)].append(value)
    else:
        d[(int(key) * 2)] = [value]

print(update_dictionary(d, 1, -1))  # None
print(d)                            # {2: [-1]}
update_dictionary(d, 2, -2)
print(d)                            # {2: [-1, -2]}
update_dictionary(d, 1, -3)
print(d)  """

# Когда Антон прочитал «Войну и мир», ему стало интересно, сколько слов и в каком количестве используется в этой книге.
# Помогите Антону написать упрощённую версию такой программы, которая сможет подсчитать слова, разделённые пробелом и вывести получившуюся статистику.
# Программа должна считывать одну строку со стандартного ввода и выводить для каждого уникального слова в этой строке число его повторений (без учёта регистра) в
# формате "слово количество" (см. пример вывода).
# Порядок вывода слов может быть произвольным, каждое уникальное слово﻿ должно выводиться только один раз.

""" a = input().lower().split(' ')
count = 0
res = ''
list_of_a = set(a)

for i in list_of_a:
    count = 0
    for j in a:
        if i == j:
            count += 1
    res = i + ' ' + str(count)
    print(res) """

# Напишите программу, которая считывает строку с числом nn, которое задаёт количество чисел, которые нужно считать. Далее считывает nn строк с числами x_ix i
#, по одному числу в каждой строке. Итого будет n+1n+1 строк.
# При считывании числа x_ix i
# программа должна на отдельной строке вывести значение f(x_i)f(x i). Функция f(x) уже реализована и доступна для вызова. 
# Функция вычисляется достаточно долго и зависит только от переданного аргумента xx. 
# Для того, чтобы уложиться в ограничение по времени, нужно избежать повторного вычисления значений.    

""" d={}
k=[]
n=int(input())
for i in range(n):
    x = int(input())
    k.append(x)
for j in range(0,len(k)):
    key=k[j]
    if  key in d:
        print(d[key])
    elif key not in d:
        p = k[j]
        d[key]=f(p)
        print(d.get(key)) """

# Напишите программу, которая считывает из файла строку, соответствующую тексту, сжатому с помощью кодирования повторов, 
# и производит обратную операцию, получая исходный текст.
# Запишите полученный текст в файл и прикрепите его, как ответ на это задание.

""" list_of_digit = []
list_of_alpha = []
result = ''
with open('dataset_3363_2.txt', 'r') as file:
    #l = [int(l) for l in str.split(file) if l.isdigit()]
    for line in file:
        strr = line
        a = line
        for i in a:
            if i.isalpha():
                list_of_alpha.append(i)
                strr = strr.replace(i, ' ')
    list_of_digit = strr.split()
    for i in range(len(list_of_digit)):
        result += int(list_of_digit[i]) * list_of_alpha[i]
    with open('res_file.txt', 'w') as res_file:
        res_file.write(result) """

# Напишите программу, которая считывает текст из файла (в файле может быть больше одной строки) и выводит самое частое слово в этом тексте и через пробел то, 
# сколько раз оно встретилось. Если таких слов несколько, вывести лексикографически первое (можно использовать оператор < для строк).

""" list_of_a = []
count = 0
max_res = ''

with open('dataset_3363_3.txt', 'r') as file:
    for line in file:
        a = line.lower().split()
        for i in a:
            list_of_a.append(i)

for i in range(len(list_of_a) - 1):
    if count < list_of_a.count(list_of_a[i]):
        max_res = list_of_a[i]
        count = list_of_a.count(list_of_a[i])
    elif count == list_of_a.count(list_of_a[i]):
        if max_res < list_of_a[i]:
            max_res = list_of_a[i]
            count = list_of_a.count(list_of_a[i])
print(max_res, count) """

# Имеется файл с данными по успеваемости абитуриентов. Он представляет из себя набор строк, где в каждой строке записана следующая информация:
# Фамилия;Оценка_по_математике;Оценка_по_физике;Оценка_по_русскому_языку
# Поля внутри строки разделены точкой с запятой, оценки — целые числа.
# Напишите программу, которая считывает исходный файл с подобной структурой и для каждого абитуриента записывает его среднюю оценку по трём предметам на отдельной строке, 
# соответствующей этому абитуриенту, в файл с ответом.
# Также вычислите средние баллы по математике, физике и русскому языку по всем абитуриентам и добавьте полученные значения, 
# разделённые пробелом, последней строкой в файл с ответом.
# В качестве ответа на задание прикрепите полученный файл со средними оценками по каждому ученику и одной строкой со средними оценками по трём предметам.

""" list_of_stud = []
result = ''
math = 0.0
fis = 0.0
rus = 0.0
with open('dataset_3363_4.txt', 'r') as file:
    for line in file:
        list_of_stud.append(line.replace('\n','').split(';'))
for i in range(len(list_of_stud)):
    result += str((int(list_of_stud[i][1]) + int(list_of_stud[i][2]) + int(list_of_stud[i][3])) / 3) + '\n'
    math += float(list_of_stud[i][1])
    fis += float(list_of_stud[i][2])
    rus += float(list_of_stud[i][3])
result += str(math / len(list_of_stud)) + ' ' + str(fis / len(list_of_stud)) + ' ' + str(rus / len(list_of_stud))
print(result) """

# Напишите программу, которая подключает модуль math и, используя значение числа \piπ из этого модуля, 
# находит для переданного ей на стандартный ввод радиуса круга периметр этого круга и выводит его на стандартный вывод.

""" import math

a = int(input())

L = 2 * a * math.pi

print(L) """

# Напишите программу, которая запускается из консоли и печатает значения всех переданных аргументов на экран (имя скрипта выводить не нужно). 
# Не изменяйте порядок аргументов при выводе.
# Для доступа к аргументам командной строки программы подключите модуль sys и используйте переменную argv из этого модуля

""" import sys

for i in range(1,len(sys.argv)):
    print(sys.argv[i]) """

# Скачайте файл. В нём указан адрес другого файла, который нужно скачать с использованием модуля requests и посчитать число строк в нём.
# Используйте функцию get для получения файла (имеет смысл вызвать метод strip к передаваемому параметру, чтобы убрать пробельные символы по краям).
# После получения файла вы можете проверить результат, обратившись к полю text. Если результат работы скрипта не принимается, проверьте поле url на правильность. 
# Для подсчёта количества строк разбейте текст с помощью метода splitlines.
# В поле ответа введите одно число или отправьте файл, содержащий одно число.

""" import requests

with open('dataset_3378_2.txt', 'r') as file:
    link = file.readline().strip()
print(link)

r = requests.get(link)
print(len(r.text.splitlines())) """

# Имеется набор файлов, каждый из которых, кроме последнего, содержит имя следующего файла.
# Первое слово в тексте последнего файла: "We".
# Скачайте предложенный файл. В нём содержится ссылка на первый файл из этого набора.

""" import requests

with open('dataset_3378_3.txt','r') as file:
    link = file.readline().strip()
r = requests.get(link)
while len(r.text) == 10: 
    link = 'https://stepic.org/media/attachments/course67/3.6.3/'+r.text
    r = requests.get(link)
    print(r.text)
with open('test.py','w') as file:
    file.write(r.text)
print(r.text) """

# Напишите программу, которая принимает на стандартный вход список игр футбольных команд с результатом матча и выводит на стандартный вывод сводную таблицу 
# результатов всех матчей.
# За победу команде начисляется 3 очка, за поражение — 0, за ничью — 1.
# Формат ввода следующий:
# В первой строке указано целое число nn — количество завершенных игр.
# После этого идет nn строк, в которых записаны результаты игры в следующем формате:
# Первая_команда;Забито_первой_командой;Вторая_команда;Забито_второй_командой
# Вывод программы необходимо оформить следующим образом:
# Команда:Всего_игр Побед Ничьих Поражений Всего_очков

""" sum_games = int(input())
list_games = [input().split(';') for i in range(sum_games)]
com = [(i[0], i[2]) for i in list_games]
import itertools
clubs = set(itertools.chain.from_iterable(com))
res = {club:[0,0,0,0,0] for club in clubs}
for kom1, gol1, kom2, gol2 in list_games:
    res[kom1][0] +=1
    res[kom2][0] +=1
    if int(gol1) > int(gol2):
        res[kom1][1] +=1
        res[kom1][4] +=3
        res[kom2][3] +=1
    elif int(gol2) > int(gol1):
        res[kom2][1] +=1
        res[kom2][4] +=3
        res[kom1][3] +=1
    else:
        res[kom1][2] +=1
        res[kom1][4] +=1
        res[kom2][2] +=1
        res[kom2][4] +=1
for i in res:
    print(i+':', ' '.join(map(str, res[i]))) """

# В какой-то момент в Институте биоинформатики биологи перестали понимать, что говорят информатики: они говорили каким-то странным набором звуков.
# В какой-то момент один из биологов раскрыл секрет информатиков: они использовали при общении подстановочный шифр, 
# т.е. заменяли каждый символ исходного сообщения на соответствующий ему другой символ. Биологи раздобыли ключ к шифру и теперь нуждаются в помощи:
# Напишите программу, которая умеет шифровать и расшифровывать шифр подстановки. Программа принимает на вход две строки одинаковой длины, 
# на первой строке записаны символы исходного алфавита, на второй строке — символы конечного алфавита, после чего идёт строка, которую нужно зашифровать переданным ключом, 
# и ещё одна строка, которую нужно расшифровать.
# Пусть, например, на вход программе передано
# abc
# *d%#
# abacabadaba
# #*%*d*%
# Это значит, что символ a исходного сообщения заменяется на символ * в шифре, b заменяется на d, c — на % и d — на #.
# Нужно зашифровать строку abacabadaba и расшифровать строку #*%*d*% с помощью этого шифра. Получаем следующие строки, которые и передаём на вывод программы:
# *d*%*d*#*d*
# dacabac

""" list_of_encryp = [[i.split() for i in input()] for j in range(4)]
list1 = []
list2 = []
for i in range(len(list_of_encryp[2])):
    for j in range(len(list_of_encryp[0])):
        if list_of_encryp[2][i] == list_of_encryp[0][j]:
            list1.append(list_of_encryp[1][j][0])

for i in list_of_encryp[3]:
    for j in range(len(list_of_encryp[1])):
        if i == list_of_encryp[1][j]:
            list2.append(list_of_encryp[0][j][0])

print(''.join(map(str,list1)))
print(''.join(map(str,list2))) """

# Простейшая система проверки орфографии может быть основана на использовании списка известных слов.
# Если введённое слово не найдено в этом списке, оно помечается как "ошибка".
# Попробуем написать подобную систему.
# На вход программе первой строкой передаётся количество dd известных нам слов, после чего на dd строках указываются эти слова. 
# Затем передаётся количество ll строк текста для проверки, после чего ll строк текста.
# Выведите уникальные "ошибки" в произвольном порядке. Работу производите без учёта регистра.

""" n = int(input())
list_of_dict = [input().lower() for i in range(n)]
l = int(input())
list_of_words = [input().lower().split() for i in range(l)]
list_of_corr = set()

for l in list_of_words:
    for j in l:
        if j not in list_of_dict:
            list_of_corr.update({j})

for i in list_of_corr:
    print(i) """

# Группа биологов в институте биоинформатики завела себе черепашку.
# После дрессировки черепашка научилась понимать и запоминать указания биологов следующего вида
# север 10
# запад 20
# юг 30
# восток 40
# где первое слово — это направление, в котором должна двигаться черепашка, а число после слова — это положительное расстояние в сантиметрах, которое должна пройти черепашка.
# Но команды даются быстро, а черепашка ползёт медленно, и программисты догадались, что можно написать программу, которая определит, куда в итоге биологи приведут черепашку. 
# Для этого программисты просят вас написать программу, которая выведет точку, в которой окажется черепашка после всех команд. Для простоты они решили считать, 
# что движение начинается в точке (0, 0), и движение на восток увеличивает первую координату, а на север — вторую.
# Программе подаётся на вход число команд nn, которые нужно выполнить черепашке, после чего nn строк с самими командами. Вывести нужно два числа в одну строку: 
# первую и вторую координату конечной точки черепашки. Все координаты целочисленные.

""" n = int(input())
list_of_coor = [input().split(' ') for i in range(n)]
napr = {}
X = 0
Y = 0
for i in range(len(list_of_coor)):
    napr[list_of_coor[i][0]] = list_of_coor[i][1]

for key,val in list_of_coor:
    if key == 'север':
        Y += int(val)
    elif key == 'юг':
        Y -= int(val)
    elif key == 'запад':
        X -= int(val)
    elif key == 'восток':
        X += int(val)
print(X, Y) """

# Дан файл с таблицей в формате TSV с информацией о росте школьников разных классов.
# Напишите программу, которая прочитает этот файл и подсчитает для каждого класса средний рост учащегося.
# Файл состоит из набора строк, каждая из которых представляет собой три поля:
# Класс Фамилия Рост
# Класс обозначается только числом. Буквенные модификаторы не используются. Номер класса может быть от 1 до 11 включительно. В фамилии нет пробелов, 
# а в качестве роста используется натуральное число, но при подсчёте среднего требуется вычислить значение в виде вещественного числа.
# Выводить информацию о среднем росте следует в порядке возрастания номера класса (для классов с первого по одиннадцатый). 
# Если про какой-то класс нет информации, необходимо вывести напротив него прочерк.

""" dict_of_height = {'1':[], '2':[], '3':[], '4':[], '5':[], '6':[], '7':[], '8':[], '9':[], '10':[], '11':[]}
sum = 0
with open('dataset_3380_5.txt','r') as file:
    for line in file:
        list = line.split()
        dict_of_height[list[0]].append(list[2])

for value in dict_of_height:
    if dict_of_height[value] == []:
        print(value, '-')
    else:
        for i in dict_of_height[value]:
            sum += int(i)
        print(value, sum / len(dict_of_height[value]))
        sum = 0 """